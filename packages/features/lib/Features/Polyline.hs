-----------------------------------------------------------------------------
{- |
Module      :  Features.Polyline
Copyright   :  (c) Alberto Ruiz 2007-11
License     :  GPL

Maintainer  :  Alberto Ruiz (aruiz at um dot es)
Stability   :  provisional

Contour Extraction.

-}
-----------------------------------------------------------------------------

module Features.Polyline (
    otsuContours,
    localOtsuContours,
    contours,
    rawContour,
    contourAt
)
where

import ImagProc
import Contours
import ImagProc.Ipp.Core
import Foreign.C.Types(CUChar)
import System.IO.Unsafe(unsafePerformIO)
import Debug.Trace
import Data.List(sortBy, maximumBy, zipWith4, sort,foldl', tails)
import Numeric.LinearAlgebra
import Util.Homogeneous
import Util.Misc(diagl)
import Util.Rotation
import Util.Misc(degree,debug)
import Numeric.GSL.Polynomials(polySolve)
import Numeric.GSL.Fourier(ifft)



data Dir = ToRight | ToLeft | ToDown | ToUp deriving Eq
nextPos :: ImageGray -> CUChar -> (Pixel,Dir) -> (Pixel,Dir)

nextPos im v (Pixel r c, ToRight) = case (a,b) of
    (False,False) -> (Pixel (r+1) c, ToDown)
    (False,True)  -> (Pixel r (c+1), ToRight)
    _             -> (Pixel (r-1) c, ToUp)
  where
    a = val8u im (Pixel (r-1) c) == v
    b = val8u im (Pixel r c) == v

nextPos im v (Pixel r c, ToDown) = case (a,b) of
    (False,False) -> (Pixel r (c-1), ToLeft)
    (False,True)  -> (Pixel (r+1) c, ToDown)
    _             -> (Pixel r (c+1), ToRight)
  where
    a = val8u im (Pixel r c) == v
    b = val8u im (Pixel r (c-1)) == v

nextPos im v (Pixel r c, ToLeft) = case (a,b) of
    (False,False) -> (Pixel (r-1) c, ToUp)
    (False,True)  -> (Pixel r (c-1), ToLeft)
    _             -> (Pixel (r+1) c, ToDown)
  where
    a = val8u im (Pixel r (c-1)) == v
    b = val8u im (Pixel (r-1) (c-1)) == v

nextPos im v (Pixel r c, ToUp) = case (a,b) of
    (False,False) -> (Pixel r (c+1), ToRight)
    (False,True)  -> (Pixel (r-1) c, ToUp)
    _             -> (Pixel r (c-1), ToLeft)
  where
    a = val8u im (Pixel (r-1) (c-1)) == v
    b = val8u im (Pixel (r-1) c) == v


-- | extracts a contour with given value from an image.
--   Don't use it if the region touches the limit of the image ROI.
rawContour :: ImageGray -- ^ source image
           -> Pixel     -- ^ starting point of the contour (a top-left corner)
           -> CUChar    -- ^ pixel value of the region (typically generated by some kind of floodFill or thresholding)
           -> [Pixel]   -- ^ contour of the region
rawContour im start v = clean $ iterate (nextPos im v) (start, ToRight)
    where clean ((a,_):rest) = a : clean' a rest
          clean' p ((v1,s1):rest@((v2,s2):_))
            | p  == v1  = []
            | s1 == s2  = clean' p rest
            | otherwise = v1: clean' p rest



-- | extracts a list of contours in the image
contours :: Int       -- ^ maximum number of contours
         -> Int       -- ^ minimum area (in pixels) of the admissible contours
         -> CUChar    -- ^ binarization threshold
         -> Bool      -- ^ binarization mode (True/False ->detect white/black regions)
         -> ImageGray -- ^ image source
         -> [([Pixel],Int,ROI)]  -- ^ list of contours, with area and ROI
contours n d th mode im = unsafePerformIO $ do
    aux <- cloneClear $ (if mode then id else notI) (binarize8u th im)
    r <- auxCont n d aux
    return r



auxCont n d aux = do
    let (v,p) = maxIndx8u aux
    if n==0 || (v<255)
        then return []
        else do
            (r@(ROI r1 r2 c1 c2),a,_) <- floodFill8u aux p 128
            let ROI lr1 lr2 lc1 lc2 = theROI aux
            if a < d || r1 == lr1 || c1 == lc1 || r2 == lr2 || c2 == lc2
                    then auxCont n d aux
                    else do
                    let c = rawContour aux p 128
                    rest <- auxCont (n-1) d aux
                    return ((c,a,r):rest)


contourAt :: Int -> ImageGray -> Pixel -> Maybe [Pixel]
contourAt dif img start = unsafePerformIO $ do
    aux <- cloneClear (median Mask5x5 img)
    let ROI lr1 lr2 lc1 lc2 = theROI aux
        d = fromIntegral dif
    (r@(ROI r1 r2 c1 c2),a,_) <- floodFill8uGrad aux start d d 0
    let st = findStart aux start
        touches = r1 == lr1 || c1 == lc1 || r2 == lr2 || c2 == lc2
        pol = if not touches
                then Just (rawContour aux st 0)
                else Nothing
    return pol

findStart im = fixp (findLimit im left . findLimit im top)

findLimit im dir pix
    | val8u im neig == 0 = findLimit im dir neig
    | otherwise          = pix
  where neig = dir pix

top  (Pixel r c) = Pixel (r-1) c
left (Pixel r c) = Pixel r (c-1)

fixp f p = if s == p then p else fixp f s
    where s = f p

--------------------------------------------------------------------------------

localOtsuContours :: Double -> ImageGray -> (([Polyline],[Polyline]),[Polyline])
localOtsuContours fracPix g = ((concatMap subcont subims,[]),[])
  where
    regs = filter (big.roiSize) $ map region $ map lst3 $ contours 1000 30 128 True sal
      where
        region = shrink (-10,-10) . poly2roi (size g) . roi2poly (size sal)

    lst3 (_,_,a) = a
    fst3 (a,_,_) = a
    big (Size h w) = w > 32 && h > 32 
    gp = g
    b = filterBox8u 5 5 gp    
    sal = compare8u IppCmpGreaterEq b gp

    redu = if fracPix < 0.1 then id else douglasPeuckerClosed fracPix

    subims = map (\r -> setROI r g) regs
    
    subcont x = map (Closed . pixelsToPoints (size g) . redu . fst3)
              $ contours 3 100 128 False
              $ compareC8u (otsuThreshold x) IppCmpGreaterEq x

--------------------------------------------------------------------------------

otsuContours :: Double -> ImageGray -> (([Polyline],[Polyline]),[Polyline])
otsuContours fracPix x = ((res,[]),[])
  where
    fst3 (a,_,_) = a
    redu = if fracPix < 0.1 then id else douglasPeuckerClosed fracPix
    res = map (Closed . pixelsToPoints (size x) . redu . fst3) $ contours 1000 100 128 False otsu
    otsu = compareC8u (otsuThreshold x) IppCmpGreater x

