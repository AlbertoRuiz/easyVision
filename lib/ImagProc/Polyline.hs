-----------------------------------------------------------------------------
{- |
Module      :  ImagProc.Polyline
Copyright   :  (c) Alberto Ruiz 2007
License     :  GPL-style

Maintainer  :  Alberto Ruiz (aruiz at um dot es)
Stability   :  very provisional
Portability :  hmm...

Some operations with polylines.

-}
-----------------------------------------------------------------------------

module ImagProc.Polyline (
-- * Operations
    Polyline(..),
    perimeter,
    orientation,
-- * Reduction
    douglasPeucker,douglasPeuckerClosed,
-- * Extraction
    rawContour,
    contours
)
where

import ImagProc.Images
import ImagProc.ImageProcessing(copy8u,maxIndx8u,floodFill8u, binarize8u)
import ImagProc.Ipp.Core
import Foreign.C.Types(CUChar)
import Foreign
import Debug.Trace
import Data.List(maximumBy)

debug x = trace (show x) x

data Polyline = Closed [Point]
              | Open   [Point]

distPoints (Point a b) (Point x y) = (a-x)^2+(b-y)^2

-- | (for an open polyline is the length)
perimeter :: Polyline -> Double
perimeter (Open l) = perimeter' l
perimeter (Closed l) = perimeter' (last l:l)

perimeter' [_] = 0
perimeter' (a:b:rest) = distPoints a b + perimeter' (b:rest)

-- | Oriented area of a closed polyline. The clockwise sense is positive in the x-y world frame (\"floor\",z=0) and negative in the camera frame.
--
-- area = abs.orientation.
orientation :: Polyline -> Double
orientation (Open _) = error "undefined orientation of open polyline"
orientation (Closed l) = -0.5 * orientation' (last l:l)

orientation' [_] = 0
orientation' (Point x1 y1:r@(Point x2 y2:_)) = x1*y2-x2*y1 + orientation' r

--------------------------------------------------------------

data Dir = ToRight | ToLeft | ToDown | ToUp deriving Eq
nextPos :: ImageGray -> CUChar -> (Pixel,Dir) -> (Pixel,Dir)

nextPos im v (Pixel r c, ToRight) = case (a,b) of
    (False,False) -> (Pixel (r+1) c, ToDown)
    (False,True)  -> (Pixel r (c+1), ToRight)
    _             -> (Pixel (r-1) c, ToUp)
  where
    a = val8u im (Pixel (r-1) c) == v
    b = val8u im (Pixel r c) == v

nextPos im v (Pixel r c, ToDown) = case (a,b) of
    (False,False) -> (Pixel r (c-1), ToLeft)
    (False,True)  -> (Pixel (r+1) c, ToDown)
    _             -> (Pixel r (c+1), ToRight)
  where
    a = val8u im (Pixel r c) == v
    b = val8u im (Pixel r (c-1)) == v

nextPos im v (Pixel r c, ToLeft) = case (a,b) of
    (False,False) -> (Pixel (r-1) c, ToUp)
    (False,True)  -> (Pixel r (c-1), ToLeft)
    _             -> (Pixel (r+1) c, ToDown)
  where
    a = val8u im (Pixel r (c-1)) == v
    b = val8u im (Pixel (r-1) (c-1)) == v

nextPos im v (Pixel r c, ToUp) = case (a,b) of
    (False,False) -> (Pixel r (c+1), ToRight)
    (False,True)  -> (Pixel (r-1) c, ToUp)
    _             -> (Pixel r (c-1), ToLeft)
  where
    a = val8u im (Pixel (r-1) (c-1)) == v
    b = val8u im (Pixel (r-1) c) == v


-- | extracts a contour with given value from an image.
--   Don't use it if the region touches the limit of the image ROI.
rawContour :: ImageGray -- ^ source image
           -> Pixel     -- ^ starting point of the contour (a top-left corner)
           -> CUChar    -- ^ pixel value of the region (typically generated by some kind of floodFill or thresholding)
           -> [Pixel]   -- ^ contour of the region
rawContour im start v = clean $ iterate (nextPos im v) (start, ToRight)
    where clean ((a,_):rest) = a : clean' a rest
          clean' p ((v1,s1):rest@((v2,s2):_))
            | p  == v1  = []
            | s1 == s2  = clean' p rest
            | otherwise = v1: clean' p rest



-- | extracts a list of contours in the image
contours :: Int       -- ^ maximum number of contours
         -> Int       -- ^ minimum area (in pixels) of the admissible contours
         -> CUChar    -- ^ binarization threshold
         -> Bool      -- ^ binarization mode (True/False ->detect white/black regions)
         -> ImageGray -- ^ image source
         -> [([Pixel],Int,ROI)]  -- ^ list of contours, with area and ROI
contours n d th mode im = unsafePerformIO $ do
    aux <- binarize8u th mode im >>= copy8u
    auxCont n d aux

auxCont n d aux = do
    let (v,p) = maxIndx8u aux
    if n==0 || (v<255)
        then return []
        else do
            (r@(ROI r1 r2 c1 c2),a,_) <- floodFill8u aux p 128
            let ROI lr1 lr2 lc1 lc2 = theROI aux
            if a < d || r1 == lr1 || c1 == lc1 || r2 == lr2 || c2 == lc2
                    then auxCont n d aux
                    else do
                    let c = rawContour aux p 128
                    rest <- auxCont (n-1) d aux
                    return ((c,a,r):rest)


----------------------------------------------------------------------

-- | Removes nodes in closed polyline such that the orthogonal distance 
--   from the remaining line is less than a given epsilon
douglasPeuckerClosed :: Double -> [Pixel] -> [Pixel]
douglasPeuckerClosed eps (a:b:ls) = b : case criticalPoint (eps^2) b a ls of
    Nothing -> [b]
    Just c  -> left ++ right where
        (l,_:r) = break (==c) ls
        left = douglasPeucker' (eps^2) b c l
        right = douglasPeucker' (eps^2) c a r

-- | Removes nodes in an open polyline such that the orthogonal distance 
--   from the remaining line is less than a given epsilon
douglasPeucker :: Double -> [Pixel] -> [Pixel]
douglasPeucker eps list = a: douglasPeucker' (eps^2) a b list
    where a = head list
          b = last list

douglasPeucker' eps2 a b ls = case criticalPoint eps2 a b ls of
    Nothing -> [b]
    Just c  -> left ++ right where
        (l,_:r) = break (==c) ls
        left = douglasPeucker' eps2 a c l
        right = douglasPeucker' eps2 c b r

perpDistAux :: Int -> Int -> Double -> Int -> Int -> Int -> Int -> Double
perpDistAux lx ly l2 x1 y1 x3 y3 = d2 where
    d2 = p2 - a'*a'/l2
    p2   = fromIntegral $ px*px + py*py
    px   = x3-x1
    py   = y3-y1
    a'   = fromIntegral $ lx*px+ly*py

perpDist (Pixel x1 y1) (Pixel x2 y2) = (f,l2) where
    lx = x2-x1
    ly = y2-y1
    l2 = fromIntegral $ lx*lx+ly*ly
    f (Pixel x3 y3) = perpDistAux lx ly l2 x1 y1 x3 y3

on f g = \x y -> f (g x) (g y)

criticalPoint eps p1 p2 [] = Nothing

criticalPoint eps2 p1 p2 p3s = r where
    (f,l2) = perpDist p1 p2
    p3 = maximumBy (compare `on` f) p3s
    r = if f p3 > eps2
        then Just p3
        else Nothing
